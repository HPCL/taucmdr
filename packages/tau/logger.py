# -*- coding: utf-8 -*-
#
# Copyright (c) 2015, ParaTools, Inc.
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# (1) Redistributions of source code must retain the above copyright notice,
#     this list of conditions and the following disclaimer.
# (2) Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
# (3) Neither the name of ParaTools, Inc. nor the names of its contributors may
#     be used to endorse or promote products derived from this software without
#     specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""TAU Commander logging.

TAU Commander has two channels for communicating with the user:
    1) sys.stdout via :any:`print`.
       Use this for messages the user has requested, e.g. a project listing.
    2) sys.stdout and sys.stderr via :any:`tau.logger`.
       Use this for status messages generated by TAU Commander.

TAU Commander also logs all status messages at the highest reporting level to
a rotating debug file in the user's TAU Commander project prefix, typically "~/.tau".
"""

import os
import sys
import errno
import logging
import textwrap
import socket
import platform
import string
from datetime import datetime
from logging import handlers
from tau import USER_PREFIX


def get_terminal_size():
    """Discover the size of the user's terminal.
    
    Several methods are attempted depending on the user's OS.
    If no method succeeds then default to (80, 25).
    
    Returns:
        tuple: (width, height) tuple giving the dimensions of the user's terminal window in characters.
    """
    tuple_xy = _get_term_size_env()
    if not tuple_xy:
        current_os = platform.system()
        if current_os == 'Windows':
            tuple_xy = _get_term_size_windows()
            if not tuple_xy:
                # for window's python in cygwin's xterm
                tuple_xy = _get_term_size_tput()
        if current_os == 'Linux' or current_os == 'Darwin' or current_os.startswith('CYGWIN'):
            tuple_xy = _get_term_size_posix()
        if not tuple_xy:
            tuple_xy = (80, 25)
    return tuple_xy


def _get_term_size_windows():
    """Discover the size of the user's terminal on Microsoft Windows.
    
    Returns:
        tuple: (width, height) tuple giving the dimensions of the user's terminal window in characters,
               or None if the size could not be determined.
    """
    res = None
    try:
        from ctypes import windll, create_string_buffer
        # stdin handle is -10, stdout -11, stderr -12
        h = windll.kernel32.GetStdHandle(-12)
        csbi = create_string_buffer(22)
        res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)
    except:
        return None
    if res:
        import struct
        (_,_,_,_,_, left,top,right,bottom, _,_) = struct.unpack("hhhhHhhhhhh", csbi.raw)
        sizex = right - left + 1
        sizey = bottom - top + 1
        return sizex, sizey
    else:
        return None


def _get_term_size_tput():
    """Discover the size of the user's terminal via `tput`_.
    
    Returns:
        tuple: (width, height) tuple giving the dimensions of the user's terminal window in characters,
               or None if the size could not be determined.
               
    .. _tput: http://stackoverflow.com/questions/263890/how-do-i-find-the-width-height-of-a-terminal-window
    """
    try:
        import subprocess
        proc = subprocess.Popen(["tput", "cols"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        output = proc.communicate(input=None)
        cols = int(output[0])
        proc = subprocess.Popen(["tput", "lines"], stdin=subprocess.PIPE, stdout=subprocess.PIPE)
        output = proc.communicate(input=None)
        rows = int(output[0])
        return (cols, rows)
    except:
        return None


def _get_term_size_posix():
    """Discover the size of the user's terminal on a POSIX operating system (e.g. Linux).
    
    Returns:
        tuple: (width, height) tuple giving the dimensions of the user's terminal window in characters,
               or None if the size could not be determined.
    """
    # This function follows a POSIX naming scheme, not Python's.
    # pylint: disable=invalid-name
    def ioctl_GWINSZ(fd):
        try:
            import fcntl
            import termios
            import struct
            dims = struct.unpack('hh', fcntl.ioctl(fd, termios.TIOCGWINSZ, '1234'))
        except:
            return None
        return dims
    dims = ioctl_GWINSZ(0) or ioctl_GWINSZ(1) or ioctl_GWINSZ(2)
    if not dims:
        try:
            fd = os.open(os.ctermid(), os.O_RDONLY)
            dims = ioctl_GWINSZ(fd)
            os.close(fd)
        except:
            pass
    if not dims:
        return None
    return int(dims[1]), int(dims[0])


def _get_term_size_env():
    """Discover the size of the user's terminal via environment variables.
    
    The user may set the LINES and COLUMNS environment variables to control TAU Commander's
    console dimension calculations.
    
    Returns:
        tuple: (width, height) tuple giving the dimensions of the user's terminal window in characters,
               or None if the size could not be determined.
    """
    try:
        return (os.environ['LINES'], os.environ['COLUMNS'])
    except KeyError:
        return None


class LogFormatter(logging.Formatter, object):
    """Custom log message formatter.
    
    Controls message formatting for all levels.
    
    Args:
        line_width (int): Maximum length of a message line before line is wrapped.
        line_marker (str): Prefix for every line of the message.
        printable_only (bool): If True, never send unprintable characters to :any:`sys.stdout`.
    """
    
    PRINTABLE_CHARS = set(string.printable)
    
    def __init__(self, line_width, line_marker, printable_only=False):
        super(LogFormatter, self).__init__()
        self.line_width = line_width
        self.line_marker = line_marker
        self.printable_only = printable_only
        self._text_wrapper = textwrap.TextWrapper(width=line_width,
                                                  subsequent_indent=line_marker + '    ',
                                                  break_long_words=False,
                                                  break_on_hyphens=False,
                                                  drop_whitespace=False)
        self._formats = {logging.CRITICAL: lambda r: self._msgbox(r, '!'),
                         logging.ERROR: lambda r: self._msgbox(r, '!'),
                         logging.WARNING: lambda r: self._msgbox(r, '*'),
                         logging.INFO: lambda r: '\n'.join(self._textwrap_message(r)),
                         logging.DEBUG: self._debug_message}

    def format(self, record):
        """Formats a log record.
        
        Args:
            record (LogRecord): LogRecord instance to format.
        
        Returns:
            str: The formatted record message.
            
        Raises:
            RuntimeError: No format specified for a the record's logging level.
        """
        try:
            return self._formats[record.levelno](record)
        except KeyError:
            raise RuntimeError('Unknown record level (name: %s)' % record.levelname)

    def _msgbox(self, record, marker):
        width = self.line_width - len(self.line_marker)
        hline = self.line_marker + marker * width
        parts = [hline, self.line_marker, '%s%s' % (self.line_marker, record.levelname)]
        parts.extend(self._textwrap_message(record))
        parts.append(hline)
        return '\n'.join(parts)
    
    def _debug_message(self, record):
        message = record.getMessage()
        if self.printable_only and (not set(message).issubset(self.PRINTABLE_CHARS)):
            message = "<<UNPRINTABLE>>"
        return '[%s %s:%s] %s' % (record.levelname, record.name, record.lineno, message)

    def _textwrap_message(self, record):
        parts = []
        for line in record.getMessage().split('\n'):
            if not self.printable_only or set(line).issubset(self.PRINTABLE_CHARS):
                message = self._text_wrapper.fill(line)
            parts.append('%s%s' % (self.line_marker, message))
        return parts


def get_logger(name):
    """Returns a customized logging object.
    
    Multiple calls to with the same name will always return a reference to the same Logger object.
    
    Args:
        name (str): Dot-separated hierarchical name for the logger.
        
    Returns:
        Logger: An instance of :any:`logging.Logger`.
    """
    return logging.getLogger(name)


def set_log_level(level):
    """Sets :any:`LOG_LEVEL`, the output level for stdout logging objects.
    
    Changes to LOG_LEVEL may affect software package verbosity. 
    
    Args:
        level (str): A string identifying the logging level, e.g. "INFO".
    """
    # Use of global statement is justified in this case.
    # pylint: disable=global-statement
    global LOG_LEVEL
    LOG_LEVEL = level.upper()
    _STDOUT_HANDLER.setLevel(LOG_LEVEL)

LOG_LEVEL = 'INFO'
"""str: The global logging level for stdout loggers and software packages.

Don't change directly. May be changed via :any:`set_log_level`.  
"""

LOG_FILE = os.path.join(USER_PREFIX, 'debug_log')
"""str: Absolute path to a log file to receive all debugging output."""

LINE_MARKER = os.environ.get('TAU_LINE_MARKER', '[TAU] ')
"""str: Marker for each line of output."""

TERM_SIZE = get_terminal_size()
"""tuple: (width, height) tuple of detected terminal dimensions in characters."""

LINE_WIDTH = TERM_SIZE[0] - len(LINE_MARKER)
"""Width of a line on the terminal.

Uses system specific methods to determine console line width.  If the line
width cannot be determined, the default is 80.
"""

_ROOT_LOGGER = logging.getLogger('tau')
if not len(_ROOT_LOGGER.handlers):
    _LOG_FILE_PREFIX = os.path.dirname(LOG_FILE)
    try:
        os.makedirs(_LOG_FILE_PREFIX)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(_LOG_FILE_PREFIX):
            pass
        else:
            raise
    _FILE_HANDLER = handlers.TimedRotatingFileHandler(LOG_FILE, when='D', interval=1, backupCount=3)
    _FILE_HANDLER.setFormatter(LogFormatter(line_width=120, line_marker=LINE_MARKER))
    _FILE_HANDLER.setLevel(logging.DEBUG)

    _STDOUT_HANDLER = logging.StreamHandler(sys.stdout)
    _STDOUT_HANDLER.setFormatter(LogFormatter(line_width=LINE_WIDTH, line_marker=LINE_MARKER, printable_only=True))
    _STDOUT_HANDLER.setLevel(LOG_LEVEL)

    _ROOT_LOGGER.addHandler(_FILE_HANDLER)
    _ROOT_LOGGER.addHandler(_STDOUT_HANDLER)
    _ROOT_LOGGER.setLevel(logging.DEBUG)

# pylint: disable=logging-not-lazy
    _ROOT_LOGGER.debug("""
%(bar)s
TAU COMMANDER LOGGING INITIALIZED

Timestamp         : %(timestamp)s
Hostname          : %(hostname)s
Platform          : %(platform)s
Python Version    : %(pyversion)s
Working Directory : %(cwd)s
Terminal Size     : %(termsize)s
%(bar)s
""" % {'bar': '#' * LINE_WIDTH,
       'timestamp': str(datetime.now()),
       'hostname': socket.gethostname(),
       'platform': platform.platform(),
       'pyversion': platform.python_version(),
       'cwd': os.getcwd(),
       'termsize': 'x'.join([str(_) for _ in TERM_SIZE])})
